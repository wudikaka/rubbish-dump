给定一个整数 num，计算所有小于等于 num 的非负整数中数字 1 出现的个数。

暴力枚举法：
核心思想：转为字符串每个位置检查是否是1
```cpp
class Solution
{
public:
    int pow10(int n)
    {
        switch (n)
        {
        case 0:
            return 1;
        case 1:
            return 10;
        case 2:
            return 100;
        case 3:
            return 1000;
        case 4:
            return 10000;
        case 5:
            return 100000;
        case 6:
            return 1000000;
        case 7:
            return 10000000;
        case 8:
            return 100000000;
        case 9:
            return 1000000000;
        default:
            return 1;
            break;
        }
    }

    int calculatenum(int num, string snum, int len)
    {
        int sum_count = 0;
        for (int i = pow10(len-1); i <= num; i++)
        {
            int count = 0;
            string current = to_string(i);
            for (string::iterator it = current.begin(); it != current.end(); it++)
            {
                if (*it == '1')
                {
                    count++;
                }
            }
            sum_count += count;
        }
		
		//10 100 1000 10000……前所有1出现的次数
        int sum[10] = {0, 1, 20, 300, 4000, 50000, 600000, 7000000, 80000000, 900000000};
        sum_count += sum[len - 1];
        return sum_count;
    }

    int digitOneInNumber(int num)
    {
        string snum = to_string(num);
        int len = snum.size();

        int sum_count = 0;
        return calculatenum(num, snum, len);
    }
};
```


高效解法：
核心思想：分别看个是百千万位上1出现的次数，比如只看个位1/11/21/31/41……/121/131/141/151……，发现每10个就出现一个个位是1的数字。
         然后每位分别检查，利用牛逼的数学公式（一般是根据具体情况推出来的）

首先看个十百千万位的时候用factor是1 10 100这些来对n消除目标位后面的数字，比如求1234的十位，这时候factor是10，可以消除4变成123，然后再取10的模求个位数字得到目标位数字。同理再加大点可以消除n目标位和目标位右侧数字得到左边的所有数字，factor取模因为正好是目标位的大小可以忽略左边数字得到右边的所有数字。
接下来因为每factor*10个数字就有factor个1，发现左边数字正好就是小于当前位置的一个大循环的当前位置上所有1出现次数的完整轮数（1234十位数上的1，有12个完整的轮），当前位置的数字决定当前位置上的带1的数字是完全没有还是有部分。
```cpp
class Solution1 {
public:
    int digitOneInNumber(int n) 
    {
        if (n <= 0) return 0;
        
        long count = 0;
        long factor = 1;  // 当前位数因子，1, 10, 100, ...表示现在在各/十/白/千/万……位
        
        while (n / factor > 0) 
		{
            long current = (n / factor) % 10;// 当前位的数字
												
            long left = n / (factor * 10);// 当前位左边的数字
            
            long right = n % factor;// 当前位右边的数字
												//若1234：
												//个位：
												//当前位置：current=(1234 / 1) % 10 = 4 
												//左边全部：left = 1234 / 10 = 123
												//右边全部：right = 1234 % 1 = 0
												//十位：
												//当前位置：current=(1234 / 10) % 10 = 3 
												//左边全部：left = 1234 / 100 = 12
												//右边全部：right = 1234 % 10 = 4
												//百位：
												//当前位置：current=(1234 / 100) % 10 = 2 
												//左边全部：left = 1234 / 1000 = 1
												//右边全部：right = 1234 % 100 = 34
												//千位：
												//当前位置：current=(1234 / 1000) % 10 = 1 
												//左边全部：left = 1234 / 10000 = 0
												//右边全部：right = 1234 % 1000 = 234
			//把个是百千万……位上出现的1全部独立出来分别统计
			//发现个位每10个出现1个  		1，11，21，31，41……
			//    十位每100出现10个  	10/11/12/13/14/15/16/17/18/19，110/111/112/113……
			//	  百位每1000个出现100个	100/101/102……110/111/112……，1100/1101/1102……
			//	  千位每10000个出现1000个
			//	以此类推
			
            if (current == 0) 
			{
                // 当前位为0时，1的个数由高位决定
                count += left * factor;
	        } 
			//若当前位置current=0  
			//1的总个数由高位决定
			//count += 12 * 10 = 120  1204  1200以前有12个完整的10~19
			//count += 128 * 1 = 128  1280  1280以前有128个个位数为1的 1 11 21……1261 1271
			
			else if (current == 1) 
			{
                // 当前位为1时，1的个数由高位和低位共同决定
                count += left * factor + right + 1;
            }
			//若当前位置current=1  
			//1的总个数由高位和低位共同决定
			//count += 12 * 10 + 4 + 1 = 125  1214  1200以前有12个完整的10~19
			//										以后有不完整的10~19，10/11/12/13/14
			//count += 128 * 1 + 0 + 1 = 129  1281  1280以前有128个个位数为1的
			//										以后有1个1281
			
			else 
			{
                // 当前位大于1时，1的个数由高位决定
                count += (left + 1) * factor;
            }
            //若当前位置current>1  如3  
			//1的总个数由高位决定
			//count += (12 + 1) * 10 = 130  1234  1200以前有12个完整的10~19
			//									  以后由于十位数>=2，也有完整的10~19
			//count += (128 + 1) * 1 = 129  1283  1283以前有128个个位数为1的
			//									  以后再多个1281
            
			factor *= 10;   //检查下一位
        }
        
        return count;
    }
};
```


# 力扣33. 搜索旋转排序数组
自己的：把数组转有序进行二分查找，再根据公式返回原数组的位置
```cpp
class Solution
{
public:
    int erfen(vector<int> &mynums, int target)
    {
        int l = 0;
        int r = mynums.size()-1;
        int mid = 0;
        while (l <= r)// 0 1 2 4 5 6 7
        {
            mid = l + (r - l) / 2;
            if (mynums[mid] < target)
            {
                l = mid + 1;
            }
            else if (mynums[mid] > target)
            {
                r = mid - 1;
            }
            else
            {
                return mid;
            }
        }
        return -1;
    }
```

```cpp
    int search(vector<int> &nums, int target)
    {
        auto min_it = min_element(nums.begin(), nums.end());//迭代器
        int min_index = distance(nums.begin(), min_it); // 最小值位置
        int k = nums.size() - min_index ;//最小的元素（包括自己）往后有几个元素，k是几

        sort(nums.begin(), nums.end());//变有序

        int pos = erfen(nums, target);//二分查找出有序数组中target的位置
        
        //没找到
        if (pos == -1)
            return pos;
        //找到
        //错因：k是从1开始，表示后面有几个元素，与题目中的下标不一样，但pos是下标
        //举例[4,5,6,7,0,1,2]->[0,1,2,4,5,6,7],size=7,k=3
        //若target=1,后数组返1,原数组是5,1->5,后数组位置<k就后移,1+(7-3)=5即pos=pos+(size-k)
        //若target=6,后数组返5,原数组是2,后数组位置>k就前移,5->2,5-3=2即pos=pos-k
        if (pos < k)
        {
            return pos + (nums.size() - k);
        }
        else 
        {
            return pos - k;
        }
    }
};
```



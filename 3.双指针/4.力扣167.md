给一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列，请从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2]  
以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。  
假设每个输入只对应唯一的答案，而且不可以重复使用相同的元素。     

双指针解法：   
初始定两边，根据不同条件不停往中间收缩   
```cpp
class Solution
{
public:
    vector<int> twoSum(vector<int> &numbers, int target)
    {
        int size = numbers.size();
        int low = 0;
        int high = size - 1;
        while (low < high)
        {
            int sum = numbers[low] + numbers[high];
            if (sum == target)
            {
                return {low + 1, high + 1};
            }
            else if (sum > target)
            {
                high--;
            }
            else
            {
                low++;
            }
        }
        return {-1, -1};
    }
};
```

二分查找解法：
用for从0开始往后定住初始low，然后每次循环中算mid判断i下标和mid下标的值是否满足，往后二分查找。本质是定住了i，查找一个满足nums[i] + ? = target的元素(用mid表示)   
这里的low如果跟普通二分查找一样从i开始(从查找范围最左边)，可能算出mid会与i重合(比如 {3，3} 等)，i+1绝对避免了这个情况，而且因为每次都定住了nums[i]，也不用查它，只用查nums[mid]，从i右边开始查即可，故这个for循环里面的部分其实就是嵌入了个普通二分查找，范围是[i+1,size-1]   
```cpp
class Solution
{
public:
    vector<int> twoSum(vector<int> &numbers, int target)
    {
        for (int i = 0; i < numbers.size(); i++)
        {
            int low = i + 1; // 避免由low和high算的mid可能与i重合
            int high = numbers.size() - 1;
            while (low <= high) // 只要右边界从size - 1开始就是 <= 
            {
                int mid = low + (high - low) / 2;
                if (numbers[mid] + numbers[i] == target)
                {
                    return {i + 1, mid + 1};
                }
                else if (numbers[mid] + numbers[i] < target)
                {
                    low = mid + 1;
                }
                else
                {
                    high = mid - 1;
                }
            }
        }
        return {-1, -1};
    }
};
```
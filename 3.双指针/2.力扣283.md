给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

我写的：
核心思想：快指针把非0元素交换给慢指针
慢指针指向出现0的地方，快指针指向非0处，快指针始终向右移动，快指针把非0元素传给慢指针，每次交换或指向非0则慢指针向后移动一次
class Solution
{
public:
    void exchange(int &a,int &b)
    {
        int temp = a;
        a = b;
        b = temp;
    }

    void moveZeroes(vector<int> &nums)
    {
        int size = nums.size();
        int slowIndex = 0;
        int fastIndex = 1;
        while(fastIndex<size)
        {
            if (nums[slowIndex] == 0) // 慢指针指向0
            {
                if (nums[fastIndex] != 0) // 快指针可以交换
                {
                    exchange(nums[fastIndex], nums[slowIndex]);
                    ++slowIndex; // 交换后慢指针后移
                    // 若不可交换，则快指针继续后移但慢指针原地等待
                }
            }
            else
            {
                ++slowIndex; // 慢指针指向非0则后移一次
            }
            ++fastIndex;
        }
    }
};

官方答案：
核心思想差不多，实现方式不同
这个方法只检查快指针，上面那个先看慢指针再看快指针，这个更简洁
区别是：上面的判断更严格，要慢指针是0且快指针非0才交换，并且慢指针在0处等待快指针塞非0。下面的只需要快指针非0就往慢指针塞，殊途同归。
这里都0开始因为考虑了越界(数组长为1)。
class Solution
{
public:
    void moveZeroes(vector<int>& nums) 
    {
        int size = nums.size(), slowIndex = 0, fastIndex = 0;
        while (fastIndex < size) 
        {
            if (nums[fastIndex]) 
            {
                swap(nums[slowIndex], nums[fastIndex]);
                ++slowIndex;
            }
            ++fastIndex;
        }
    }
};

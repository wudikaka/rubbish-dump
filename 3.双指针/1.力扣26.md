给非严格递增排列的数组nums原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。  
元素的相对顺序应该保持一致。超出长度的元素忽略（实际上可以用pop_back()）  

自己的解法：  
核心思想：快慢指针始终相邻，相同则前移消除，不相同则往后一位检查
快指针往后检查，若快慢指针相同，则集体前移且长度--，保持快慢指针位置不动，因为元素前移了，下一个元素到了快指针脚下；若不相同，快慢指针都后移  
```cpp
class Solution
{
public:
    int removeDuplicates(vector<int> &nums)
    {
        int size = nums.size();
        int slowIndex = 0;
        int fastIndex = 1;
        for (; fastIndex < size; fastIndex++)
        {
            if (nums[fastIndex] == nums[slowIndex])
            {
                for (int i = fastIndex; i < size - 1; i++)
                {
                    nums[i] = nums[i + 1];
                }
                size--;
                fastIndex--;
            }
            else
            {
                slowIndex++;
            }
        }
        return size;
    }
};
```

官方解法:  
核心思想：快指针找第一次出现的数往慢指针脚下放   
首先注意数组是有序的，那么重复的元素一定会相邻，要求删除重复元素，实际上就是将不重复的元素(快指针遇到的)移到数组的左侧(慢指针的位置)。   
由于第0个元素永远不可能被替换，故从第1个开始。一开始先检查第1位和第0位元素是否相等，这正是从第1位开始的巧妙之处。   
不论如何，快指针始终往后移，若检测到新的值(当前位与上一位元素不同)则放到慢指针脚下，然后慢指针后移准备放新的值  
```cpp
class Solution 
{
public:
    int removeDuplicates(vector<int>& nums) 
    {
        int size = nums.size();
        if (size == 0) 
        {
            return 0;
        }
        int fastIndex = 1; 
        int slowIndex = 1;
        while (fastIndex < size) 
        {
            if (nums[fastIndex] != nums[fastIndex - 1]) 
            {
                nums[slowIndex] = nums[fastIndex];
                ++slowIndex;
            }
            ++fastIndex;
        }
        return slowIndex;
    }
};
```


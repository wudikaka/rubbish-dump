给一个有序数组 nums ，请原地删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。   

官方版本：   
核心思想：慢指针停留在将要放元素的位置，快指针寻找符合条件的元素放到慢指针脚下
由于发现让最多2个重复，并且慢指针要在将要放置元素的地方，所以慢指针要在 一个元素/重复的两个元素 后面一个位置，那么我要检查前面是否已有两个，可以用slow-2，若是两个重复的，-2之后正好是该元素值，若是两个不同的，-2后必定比fast脚下的少2不可能相等。因为要slow-2，防止越界则slow应从2开始，那么前两个就要用size<=2来分类讨论，再看看size==3时，可能需要交换，下表最大为2，故fast也从2开始-->得出结论：slow和fast在开始时最好一致。返回的可以用slow相关的式来表示，因为slow是用来放置元素的，随便写个数组模拟一下就得出了   

对核心部分的理解：由于slow左边都是放置好的，且是由fast放置的，所以slow-1是fast上一个放置的，***slow-2是fast上上个放置的，也是允许最早的重复的元素***
准备放置元素时可以视为 slow-2 slow-1 fast   
上升 slow-2 < slow-1 < fast --> 1 2 3   
        单调不递减，fast的必定比slow-2大，不相同，可放置   
     slow-2 = slow-1 < fast --> 1 1 2   
        单调不递减，fast的必定同时大于slow-2和slow-1，可放置   
重复 slow-2 < slow-1 = fast --> 1 2 2   
        只有个slow-1重复了，可以放置   
超出 slow-2 = slow-1 = fast   
        三个重复，跳过        

***本题结论：***  
***1.slow和fast在开始时最好一致***  
***2.做题前先分析考虑一下最小情况，比如元素只有1/2/3***  

```cpp
class Solution
{
public:
    int removeDuplicates(vector<int> &nums)
    {
        int size = nums.size();
        if (size <= 2)
        {
            return size;
        }
        int slowIndex = 2;
        int fastIndex = 2;

        while (fastIndex < size)
        {
            if (nums[fastIndex] != nums[slowIndex - 2])//最核心部分
            {
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
            fastIndex++;
        }
        return slowIndex;
    }
};
```
效率最低版本：拉完了  
非正常的双指针  
由于是有序，所以可以按顺序检查。每当遇到新值，慢指针移动到快指针脚下，快指针往后一位，即慢指针停在上一个快指针遇到的新值的第一个位置，快慢指针在遇到新值重置位置后相邻，并且重置标记count(表示该值元素的个数)(可能只有一个元素也可能有两个元素)。  
快指针不停往后检查，若遇到与慢指针脚下相同的元素则count++，若count=2，则执行删除和集体前移(就是这里效率很低)，由于前移，快指针脚下变成原来后面的元素，则快指针要保持位置不变；若遇到新元素则慢指针移过来且快指针后移一位，重置count  
```cpp
class Solution
{
public:
    int removeDuplicates(vector<int> &nums)
    {
        int size = nums.size();
        int slowIndex = 0;
        int fastIndex = 1;
        int count = 1;
        while (fastIndex < size)
        {
            if (nums[slowIndex] == nums[fastIndex])
            {
                if (count == 1) // 第一次重复
                {
                    count++;
                }
                else if (count == 2) // 已重复过
                { // 前移
                    for (int i = fastIndex; i < size - 1; ++i)
                    {
                        nums[i] = nums[i + 1];
                    }
                    size--;
                    fastIndex--;
                }
            }
            else
            {
                count = 1;
                slowIndex = fastIndex;
            }
            fastIndex++;
        }
        return size;
    }
};
```
版本3：
v1 v2 nums[i]三个从前往后挨着，由于元素的值只能增或相等，故当nums[i]=v1时，nums[i]=v2(nums[i]=v2不能推出=v1)。利用nums[i]!=v1来判断nums[i]脚下值是否重复(如果!=v2就是一个都不重复的逻辑)，每次判断后v1 v2 nums[i]都后移一位。  
设计v1是给nums[i]来看前两位的，v2是用来给v1往后的跳板，这里牛逼的在于，由于检查的速度必定快于/等于cnt覆盖目标结果数组的速度，所以用nums[i]和v1来判断是否重合，未重合就存到cnt处且cnt++，重合就跳过，比标准的双指针更直接。  
对nums[i]和v1的理解：  
情况一：上升v1< v2 < nums[i]  
        1 2 3--->存放  
        上升v1 = v2 < nums[i]  
        1 1 2--->存放  
情况二：重复v1 < v2 = nums[i]  
        1 2 2--->存放  
情况三：超出v1 = v2 = nums[i]  
        1 1 1--->跳过  
***发现v1是个计数器锚点，不论是上升情况还是重复情况，都是更早的那个元素，延迟了两拍，因为在nums[i]这个位置的元素要重复超过两次，必定会在v1的位置有和它相同的值，所以只要不相等就可以存放***  

```cpp
class Solution
{
public:
    int removeDuplicates(vector<int> &nums)
    {
        if (nums.size() <= 2)
            return nums.size();

        int cnt = 2;      // 先计入 nums[0], nums[1]
        int v1 = nums[0]; // 前面第二个元素
        int v2 = nums[1]; // 前面第一个元素

        for (int i = 2; i < nums.size(); i++)
        {
            // nums[i] != v2, 说明不是重复两次以上的后续元素。
            // 因为数组有序，v1 <= v2。nums[i] 如果 == v1，那么也 == v2
            if (nums[i] != v1)
            {
                cnt++;                   // 计数
                nums[cnt - 1] = nums[i]; // 放入 cnt - 1 处
                // 以上两行可以合并简化，但个人更倾向于可读性
            }
            v1 = v2;
            v2 = nums[i];
        }

        return cnt;
    }
};
```

